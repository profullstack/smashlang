// smashpkg.smash - SmashLang Package Manager

import "fs";
import "path";
import "http";
import "crypto";
import "std";

// Configuration
const PACKAGES_DIR = path.resolve("../smashlang_packages");
const MODULES_DIR = path.resolve("./smash_modules");
const CATEGORIES = ["core", "networking", "database", "community"];

// Command handlers
const commands = {
  install: installPackages,
  update: updatePackages,
  list: listPackages,
  info: showPackageInfo,
  search: searchPackages,
  help: showHelp
};

// Main function
async fn main(args) {
  if (args.length < 1) {
    return showHelp();
  }
  
  const command = args[0];
  const commandArgs = args.slice(1);
  
  if (commands[command]) {
    await commands[command](commandArgs);
  } else {
    console.error(`Unknown command: ${command}`);
    showHelp();
  }
}

// Install packages
async fn installPackages(packageNames) {
  if (packageNames.length === 0) {
    console.error("Error: No packages specified");
    return;
  }
  
  console.log("Installing packages:", packageNames.join(", "));
  
  // Create modules directory if it doesn't exist
  if (!fs.existsSync(MODULES_DIR)) {
    fs.mkdirSync(MODULES_DIR, { recursive: true });
  }
  
  for (const pkgName of packageNames) {
    // Parse package name and version
    let [name, version] = pkgName.split("@");
    
    // Find the package formula
    const formula = await findPackageFormula(name);
    
    if (!formula) {
      console.error(`Package not found: ${name}`);
      continue;
    }
    
    // Use latest version if not specified
    if (!version) {
      version = formula.version;
    }
    
    console.log(`Installing ${name}@${version}...`);
    
    // Check if package is already installed
    const pkgDir = path.join(MODULES_DIR, name);
    if (fs.existsSync(pkgDir)) {
      const installedVersion = JSON.parse(fs.readFileSync(path.join(pkgDir, "package.json"))).version;
      if (installedVersion === version) {
        console.log(`Package ${name}@${version} is already installed`);
        continue;
      }
    }
    
    // Install dependencies first
    if (formula.dependencies && formula.dependencies.length > 0) {
      console.log(`Installing dependencies for ${name}: ${formula.dependencies.join(", ")}`);
      await installPackages(formula.dependencies);
    }
    
    // Check for native dependencies
    if (formula.native_dependencies && formula.native_dependencies.length > 0) {
      console.log("Checking native dependencies...");
      checkNativeDependencies(formula.native_dependencies);
    }
    
    // Download package
    console.log(`Downloading ${formula.url}...`);
    // In a real implementation, this would download and extract the package
    // For this example, we'll just create a directory and a package.json file
    
    fs.mkdirSync(pkgDir, { recursive: true });
    
    // Create a simple package.json file
    const packageJson = {
      name: formula.name,
      version: formula.version,
      description: formula.description,
      license: formula.license
    };
    
    fs.writeFileSync(path.join(pkgDir, "package.json"), JSON.stringify(packageJson, null, 2));
    
    // Create a simple index.smash file with exports
    if (formula.exports) {
      let indexContent = "// Generated by smashpkg\n\n";
      
      // In a real implementation, this would be more sophisticated
      // For this example, we'll just add some placeholder exports
      if (typeof formula.exports === "object") {
        for (const [key, value] of Object.entries(formula.exports)) {
          if (typeof value === "string" && value.startsWith("fn ")) {
            indexContent += value + "\n\n";
          } else if (typeof value === "string" && value.startsWith("class ")) {
            indexContent += value + "\n\n";
          } else if (typeof value === "object") {
            indexContent += `const ${key} = {}; // Placeholder for nested object\n\n`;
          }
        }
      }
      
      indexContent += "// Export all functions and classes\nexport {\n";
      for (const key of Object.keys(formula.exports)) {
        indexContent += `  ${key},\n`;
      }
      indexContent += "};\n";
      
      fs.writeFileSync(path.join(pkgDir, "index.smash"), indexContent);
    }
    
    console.log(`Successfully installed ${name}@${version}`);
  }
}

// Update packages
async fn updatePackages(packageNames) {
  if (packageNames.length === 0) {
    // Update all installed packages
    const installedPackages = fs.readdirSync(MODULES_DIR);
    await installPackages(installedPackages);
  } else {
    // Update specified packages
    await installPackages(packageNames);
  }
}

// List packages
fn listPackages(args) {
  const category = args[0];
  
  if (category && !CATEGORIES.includes(category)) {
    console.error(`Unknown category: ${category}`);
    console.log(`Available categories: ${CATEGORIES.join(", ")}`);
    return;
  }
  
  console.log("Available packages:\n");
  
  for (const cat of category ? [category] : CATEGORIES) {
    console.log(`=== ${cat.toUpperCase()} ===`);
    
    const catDir = path.join(PACKAGES_DIR, cat);
    if (fs.existsSync(catDir)) {
      const packages = fs.readdirSync(catDir)
        .filter(file => file.endsWith(".smash"))
        .map(file => {
          const content = fs.readFileSync(path.join(catDir, file), "utf8");
          const formula = JSON.parse(content.substring(content.indexOf("{"), content.lastIndexOf("}") + 1));
          return `${formula.name}@${formula.version} - ${formula.description}`;
        });
      
      for (const pkg of packages) {
        console.log(`  ${pkg}`);
      }
    }
    
    console.log("");
  }
}

// Show package info
async fn showPackageInfo(args) {
  if (args.length === 0) {
    console.error("Error: No package specified");
    return;
  }
  
  const pkgName = args[0];
  const formula = await findPackageFormula(pkgName);
  
  if (!formula) {
    console.error(`Package not found: ${pkgName}`);
    return;
  }
  
  console.log(`=== ${formula.name}@${formula.version} ===`);
  console.log(`Description: ${formula.description}`);
  console.log(`License: ${formula.license}`);
  console.log(`Authors: ${formula.authors.join(", ")}`);
  
  if (formula.dependencies && formula.dependencies.length > 0) {
    console.log(`Dependencies: ${formula.dependencies.join(", ")}`);
  } else {
    console.log("Dependencies: None");
  }
  
  if (formula.exports) {
    console.log("\nExports:");
    for (const key of Object.keys(formula.exports)) {
      console.log(`  - ${key}`);
    }
  }
  
  if (formula.examples && formula.examples.length > 0) {
    console.log("\nExamples:");
    for (const example of formula.examples) {
      console.log(`  - ${example}`);
    }
  }
}

// Search packages
async fn searchPackages(args) {
  if (args.length === 0) {
    console.error("Error: No search query specified");
    return;
  }
  
  const query = args[0].toLowerCase();
  const results = [];
  
  for (const category of CATEGORIES) {
    const catDir = path.join(PACKAGES_DIR, category);
    if (fs.existsSync(catDir)) {
      const packages = fs.readdirSync(catDir)
        .filter(file => file.endsWith(".smash"));
      
      for (const file of packages) {
        const content = fs.readFileSync(path.join(catDir, file), "utf8");
        const formula = JSON.parse(content.substring(content.indexOf("{"), content.lastIndexOf("}") + 1));
        
        // Search in name, description, and tags
        if (formula.name.toLowerCase().includes(query) ||
            formula.description.toLowerCase().includes(query)) {
          results.push({
            name: formula.name,
            version: formula.version,
            description: formula.description,
            category
          });
        }
      }
    }
  }
  
  if (results.length === 0) {
    console.log(`No packages found matching '${args[0]}'`);
    return;
  }
  
  console.log(`Search results for '${args[0]}':\n`);
  for (const pkg of results) {
    console.log(`${pkg.name}@${pkg.version} [${pkg.category}]`);
    console.log(`  ${pkg.description}\n`);
  }
}

// Show help
fn showHelp() {
  console.log(`
SmashLang Package Manager

Usage: smashpkg <command> [args]

Commands:
  install <pkg1> [pkg2...]  Install packages
  update [pkg1] [pkg2...]   Update packages (all if none specified)
  list [category]           List available packages
  info <package>            Show package information
  search <query>            Search for packages
  help                      Show this help message

Examples:
  smashpkg install math
  smashpkg install sqlite@3.36.0
  smashpkg list database
  smashpkg search json
  `);
}

// Helper functions
async fn findPackageFormula(name) {
  for (const category of CATEGORIES) {
    const formulaPath = path.join(PACKAGES_DIR, category, `${name}.smash`);
    if (fs.existsSync(formulaPath)) {
      const content = fs.readFileSync(formulaPath, "utf8");
      return JSON.parse(content.substring(content.indexOf("{"), content.lastIndexOf("}") + 1));
    }
  }
  return null;
}

fn checkNativeDependencies(dependencies) {
  // In a real implementation, this would check if native dependencies are installed
  // For this example, we'll just print the dependencies
  console.log("Native dependencies required:");
  for (const dep of dependencies) {
    console.log(`  - ${dep.name} ${dep.version || ""}`);
    
    // Determine the package name for the current platform
    let pkgName = null;
    if (std.platform === "linux") {
      // Simplified detection for Linux distributions
      pkgName = dep.debian || dep.fedora || dep.arch;
    } else if (std.platform === "darwin") {
      pkgName = dep.macos;
    } else if (std.platform === "win32") {
      pkgName = dep.windows;
    }
    
    if (pkgName) {
      console.log(`    Install with your system package manager: ${pkgName}`);
    }
  }
}

// Run the main function with command-line arguments
main(std.argv.slice(2));
