/**
 * SmashLang HTTP Package
 * 
 * A comprehensive HTTP client for SmashLang applications.
 * Provides functionality for making HTTP requests, handling responses,
 * and working with various HTTP features.
 */

// HTTP methods
const HTTP_METHODS = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',
  HEAD: 'HEAD',
  OPTIONS: 'OPTIONS'
};

/**
 * Response class representing an HTTP response
 */
export class Response {
  constructor(status, statusText, headers, body, url) {
    this.status = status;
    this.statusText = statusText;
    this.headers = headers;
    this._body = body;
    this.url = url;
    this._bodyText = null;
    this._bodyJson = null;
    this._bodyBlob = null;
    this._bodyArrayBuffer = null;
  }
  
  /**
   * Whether the response was successful (status in the range 200-299)
   */
  get ok() {
    return this.status >= 200 && this.status < 300;
  }
  
  /**
   * Get the response body as text
   */
  async text() {
    if (this._bodyText !== null) {
      return this._bodyText;
    }
    
    if (typeof this._body === 'string') {
      this._bodyText = this._body;
    } else if (this._body instanceof ArrayBuffer) {
      // Convert ArrayBuffer to string
      this._bodyText = new TextDecoder().decode(this._body);
    } else if (this._body instanceof Blob) {
      // Convert Blob to string
      this._bodyText = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(this._body);
      });
    } else if (this._body === null || this._body === undefined) {
      this._bodyText = '';
    } else {
      // Try to convert to string
      this._bodyText = String(this._body);
    }
    
    return this._bodyText;
  }
  
  /**
   * Get the response body as JSON
   */
  async json() {
    if (this._bodyJson !== null) {
      return this._bodyJson;
    }
    
    const text = await this.text();
    try {
      this._bodyJson = JSON.parse(text);
    } catch (error) {
      throw new Error(`Failed to parse response as JSON: ${error.message}`);
    }
    
    return this._bodyJson;
  }
  
  /**
   * Get the response body as a Blob
   */
  async blob() {
    if (this._bodyBlob !== null) {
      return this._bodyBlob;
    }
    
    if (this._body instanceof Blob) {
      this._bodyBlob = this._body;
    } else if (this._body instanceof ArrayBuffer) {
      this._bodyBlob = new Blob([this._body]);
    } else {
      const text = await this.text();
      this._bodyBlob = new Blob([text]);
    }
    
    return this._bodyBlob;
  }
  
  /**
   * Get the response body as an ArrayBuffer
   */
  async arrayBuffer() {
    if (this._bodyArrayBuffer !== null) {
      return this._bodyArrayBuffer;
    }
    
    if (this._body instanceof ArrayBuffer) {
      this._bodyArrayBuffer = this._body;
    } else if (this._body instanceof Blob) {
      this._bodyArrayBuffer = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsArrayBuffer(this._body);
      });
    } else {
      const text = await this.text();
      this._bodyArrayBuffer = new TextEncoder().encode(text).buffer;
    }
    
    return this._bodyArrayBuffer;
  }
}

/**
 * Cookie jar for storing cookies between requests
 */
export class CookieJar {
  constructor() {
    this.cookies = {};
  }
  
  /**
   * Set a cookie in the jar
   * @param {string} cookie - Cookie string
   * @param {string} url - URL the cookie is associated with
   */
  setCookie(cookie, url) {
    const domain = new URL(url).hostname;
    
    if (!this.cookies[domain]) {
      this.cookies[domain] = [];
    }
    
    // Parse the cookie string
    const [nameValue] = cookie.split(';');
    const [name] = nameValue.split('=');
    
    // Remove existing cookie with the same name
    this.cookies[domain] = this.cookies[domain].filter(c => {
      const [existingNameValue] = c.split(';');
      const [existingName] = existingNameValue.split('=');
      return existingName.trim() !== name.trim();
    });
    
    // Add the new cookie
    this.cookies[domain].push(cookie);
  }
  
  /**
   * Get cookies for a URL
   * @param {string} url - URL to get cookies for
   * @returns {Array<string>} Array of cookie strings
   */
  getCookies(url) {
    const domain = new URL(url).hostname;
    return this.cookies[domain] || [];
  }
  
  /**
   * Get cookies as a header string for a URL
   * @param {string} url - URL to get cookies for
   * @returns {string} Cookie header string
   */
  getCookieHeader(url) {
    const cookies = this.getCookies(url);
    if (cookies.length === 0) {
      return '';
    }
    
    return cookies.map(cookie => {
      const [nameValue] = cookie.split(';');
      return nameValue.trim();
    }).join('; ');
  }
  
  /**
   * Clear all cookies
   */
  clear() {
    this.cookies = {};
  }
  
  /**
   * Clear cookies for a specific domain
   * @param {string} domain - Domain to clear cookies for
   */
  clearDomain(domain) {
    delete this.cookies[domain];
  }
}

/**
 * Main HTTP client class
 */
class HttpClient {
  /**
   * Make an HTTP request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async request(url, options = {}) {
    const {
      method = 'GET',
      headers = {},
      body = null,
      timeout = 30000,
      retries = 0,
      retryDelay = 1000,
      followRedirects = true,
      maxRedirects = 5,
      validateStatus = status => status >= 200 && status < 300,
      proxy = null,
      cookieJar = null,
      stream = false
    } = options;
    
    // Validate method
    if (!Object.values(HTTP_METHODS).includes(method.toUpperCase())) {
      throw new Error(`Invalid HTTP method: ${method}`);
    }
    
    // Prepare headers
    const requestHeaders = { ...headers };
    
    // Add cookies from jar if provided
    if (cookieJar instanceof CookieJar) {
      const cookieHeader = cookieJar.getCookieHeader(url);
      if (cookieHeader) {
        requestHeaders['Cookie'] = cookieHeader;
      }
    }
    
    // Prepare request options
    const requestOptions = {
      method: method.toUpperCase(),
      headers: requestHeaders,
      redirect: followRedirects ? 'follow' : 'manual',
      signal: timeout ? AbortSignal.timeout(timeout) : null
    };
    
    // Add body if provided
    if (body !== null && method !== 'GET' && method !== 'HEAD') {
      if (body instanceof FormData) {
        // FormData is handled automatically
        requestOptions.body = body;
      } else if (typeof body === 'object' && !(body instanceof Blob) && !(body instanceof ArrayBuffer)) {
        // Convert object to JSON
        requestOptions.body = JSON.stringify(body);
        if (!requestHeaders['Content-Type']) {
          requestHeaders['Content-Type'] = 'application/json';
        }
      } else {
        // Use body as is
        requestOptions.body = body;
      }
    }
    
    // Add proxy if provided
    if (proxy) {
      // This would require additional implementation for proxy support
      console.warn('Proxy support is not fully implemented');
    }
    
    // Make the request with retries
    let response;
    let retryCount = 0;
    let redirectCount = 0;
    let currentUrl = url;
    
    while (true) {
      try {
        response = await fetch(currentUrl, requestOptions);
        
        // Handle redirects manually if needed
        if (followRedirects && [301, 302, 303, 307, 308].includes(response.status) && 
            redirectCount < maxRedirects && response.headers.has('Location')) {
          redirectCount++;
          currentUrl = new URL(response.headers.get('Location'), currentUrl).toString();
          continue;
        }
        
        // Store cookies in jar if provided
        if (cookieJar instanceof CookieJar && response.headers.has('Set-Cookie')) {
          const cookies = response.headers.getAll('Set-Cookie');
          for (const cookie of cookies) {
            cookieJar.setCookie(cookie, currentUrl);
          }
        }
        
        // Check if response status is valid
        if (!validateStatus(response.status)) {
          throw new Error(`Request failed with status code ${response.status}`);
        }
        
        break;
      } catch (error) {
        if (retryCount >= retries) {
          throw error;
        }
        
        retryCount++;
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
    
    // Get response body
    let responseBody;
    if (stream) {
      responseBody = response.body;
    } else {
      if (response.headers.get('Content-Type')?.includes('application/json')) {
        responseBody = await response.json();
      } else {
        responseBody = await response.text();
      }
    }
    
    // Create response object
    return new Response(
      response.status,
      response.statusText,
      Object.fromEntries(response.headers.entries()),
      responseBody,
      currentUrl
    );
  }
  
  /**
   * Make a GET request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async get(url, options = {}) {
    return this.request(url, { ...options, method: 'GET' });
  }
  
  /**
   * Make a POST request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async post(url, options = {}) {
    return this.request(url, { ...options, method: 'POST' });
  }
  
  /**
   * Make a PUT request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async put(url, options = {}) {
    return this.request(url, { ...options, method: 'PUT' });
  }
  
  /**
   * Make a DELETE request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async delete(url, options = {}) {
    return this.request(url, { ...options, method: 'DELETE' });
  }
  
  /**
   * Make a PATCH request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async patch(url, options = {}) {
    return this.request(url, { ...options, method: 'PATCH' });
  }
  
  /**
   * Make a HEAD request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async head(url, options = {}) {
    return this.request(url, { ...options, method: 'HEAD' });
  }
  
  /**
   * Make an OPTIONS request
   * @param {string} url - The URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Response>} Promise resolving to a Response object
   */
  async options(url, options = {}) {
    return this.request(url, { ...options, method: 'OPTIONS' });
  }
}

// Create a singleton instance
export const http = new HttpClient();

// Export HTTP methods
export const { GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS } = HTTP_METHODS;

// Default export
export default http;