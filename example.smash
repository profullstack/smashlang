let x = [1, 2, 3];
const y = [true, false, false, true];
let user = {
    name: "chovy",
    age: 33,
};

print("age:", user.age);

for (let i of x) {
	print(i);
}

// Iterate over object properties with for...in loop
for (let val in user) {
    print(val, user[val]);
}


for (let x of y) {
    if (x) {
        print("true");
        continue;
    } else {
        print("false");
    }
}

// Sleep function using Promise with setTimeout
async fn sleep(ms) {
    print("Sleeping...");
    return new Promise((resolve, reject) => {
        setTimeout(resolve, ms);
    });
}

// Test async function
async fn test() {
    print("Starting test");
    const result = await sleep(1000);
    print("Finished sleeping");
    return result;
}

// Call the async function
print("Before await");
const result = await test();
print("After await");
print("Result:");
print(result);

let message = "Hello, SmashLang!";
let year = 2025;
let pi = 3.14;
let active = true;
let active2 = false;

if (active) {
    print(pi);
}

if (!active2) {
    print("not active", pi);
}

// Using a string-based approach for regex patterns
let pattern = "smash.*";

print(message);

// Simple Promise test
print("Promise test:");

// Create a function that returns a promise
fn createPromise() {
    return new Promise((resolve, reject) => {
        // Resolve after a delay
        setTimeout(() => {
            resolve("Promise resolved!");
        }, 1000);
    });
}

// Create a function to handle the Promise result
fn handlePromise(result) {
    print("Promise result:", result);
    return "Processed: " + result;
}

// Create a function to handle errors
fn handleError(error) {
    print("Promise error:", error);
}

// Use the Promise
const promiseResult = createPromise();

// Add handlers manually
promiseResult.then(handlePromise);
promiseResult.onCatch(handleError);

// Example of try/catch/finally blocks
print("Try/Catch/Finally example:");
try {
    print("Inside try block");
    // Throw an error
    throw new Error("Something went wrong");
    print("This will not be executed");
} catch (error) {
    print("Inside catch block");
    print("Error message: " + error);
} finally {
    print("Inside finally block - this always executes");
}

// Example of fetch with Promise chaining
print("Fetch example with Promise chaining:");

// Using variable assignment for method chaining (recommended approach)
const fetchResult = fetch("https://jsonplaceholder.typicode.com/todos/1");

const jsonResult = fetchResult.then((response) => {
    print("Response status: " + response.status);
    return response.json();
});

const processedResult = jsonResult.then((data) => {
    print("Todo title: " + data.title);
    return data;
});

processedResult.onCatch((error) => {
    print("Fetch error: " + error);
});

// Simple async/await test
print("Async/await test:");

// Helper function that returns a promise
fn createDelayPromise(ms, value) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(value);
        }, ms);
    });
}

// Define an async function
async fn processAsync() {
    try {
        print("Starting async operation...");
        
        // Use await with our delay function
        const result1 = await createDelayPromise(500, "First result");
        print("Got first result:", result1);
        
        // Chain another async operation
        const result2 = await createDelayPromise(500, "Second result: " + result1);
        print("Got second result:", result2);
        
        return "Completed: " + result2;
    } catch (error) {
        print("Async error:", error);
        return null;
    }
}

// Call the async function
print("Before calling async function");
const asyncResult = await processAsync();
print("After async function");
print("Final result:", asyncResult);
