
   _____                      _     _                       
  / ____|                    | |   | |                      
 | (___  _ __ ___   __ _ ___| |__ | |     __ _ _ __   __ _ 
  \___ \| '_ ' _ \ / _' / __| '_ \| |    / _' | '_ \ / _' |
  ____) | | | | | | (_| \__ \ | | | |___| (_| | | | | (_| |
 |_____/|_| |_| |_|\__,_|___/_| |_|______|\__,_|_| |_|\__, |
                                                        __/ |
                                                       |___/ 

ðŸ’ª Welcome to SmashLang! ðŸ’ª
A bold, high-performance, JavaScript-inspired general-purpose programming language
that compiles to native binaries. Made for developers who want the power of C/Rust
but the clarity of JavaScript â€” without the bloat.

Visit https://smashlang.com for documentation and community resources.


SmashLang Installer v0.1.0
[0;34mDetected operating system: macos[0m
[0;33mWarning: llvm-config not found. LLVM development files may be missing.[0m
[0;33mTo install LLVM development files on macOS, run: brew install llvm[0m
[0;34mInstalling SmashLang for macOS...[0m
[0;34mChecking for latest release...[0m
[0;33mNo releases found (HTTP 404). Falling back to master branch...[0m
[0;34mRunning tests for SmashLang...[0m
(Test output will be saved and summarized at the end)
[0;34mRunning main crate tests...[0m
[0;33mWarning: tests directory not found at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/tests[0m
[0;34mRunning tests for all packages...[0m
[0;34mRunning library and binary tests...[0m
    Updating crates.io index
     Locking 112 packages to latest compatible versions
      Adding colored v2.2.0 (available: v3.0.0)
      Adding inkwell v0.2.0 (available: v0.5.0)
      Adding rustyline v11.0.0 (available: v15.0.0)
   Compiling libc v0.2.171
   Compiling cfg-if v1.0.0
   Compiling memchr v2.7.4
   Compiling bitflags v2.9.0
   Compiling rustix v0.38.44
   Compiling autocfg v1.4.0
   Compiling serde v1.0.219
   Compiling smallvec v1.15.0
   Compiling shlex v1.3.0
   Compiling pkg-config v0.3.32
   Compiling bitflags v1.3.2
   Compiling serde_json v1.0.140
   Compiling rustix v1.0.5
   Compiling core-foundation-sys v0.8.7
   Compiling cc v1.2.18
   Compiling nibble_vec v0.1.0
   Compiling getrandom v0.3.2
   Compiling endian-type v0.1.2
   Compiling regex-syntax v0.8.5
   Compiling anyhow v1.0.97
   Compiling radix_trie v0.2.1
   Compiling num-traits v0.2.19
   Compiling aho-corasick v1.1.3
   Compiling iana-time-zone v0.1.63
   Compiling lazy_static v1.5.0
   Compiling unicode-segmentation v1.12.0
   Compiling ryu v1.0.20
   Compiling utf8parse v0.2.2
   Compiling itoa v1.0.15
   Compiling unicode-width v0.1.14
   Compiling log v0.4.27
   Compiling colored v2.2.0
   Compiling once_cell v1.21.3
   Compiling fastrand v2.3.0
   Compiling smashlang v0.1.0 (/private/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang)
   Compiling regex-automata v0.4.9
   Compiling errno v0.3.11
   Compiling dirs-sys-next v0.1.2
   Compiling nix v0.26.4
   Compiling dirs-next v2.0.0
   Compiling chrono v0.4.40
   Compiling fd-lock v3.0.13
   Compiling tempfile v3.19.1
   Compiling rustyline v11.0.0
   Compiling regex v1.11.1
warning: method `parse_ternary` is never used
   --> src/parser.rs:881:8
    |
230 | impl Parser {
    | ----------- method in this implementation
...
881 |     fn parse_ternary(&mut self) -> ParseResult<AstNode> {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: `smashlang` (lib) generated 1 warning
warning: `smashlang` (lib test) generated 1 warning (1 duplicate)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 11.56s
     Running unittests src/lib.rs (target/debug/deps/smashlang-da278edf4eddc46c)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/smash-04232ff50082d9e2)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/smashc.rs (target/debug/deps/smashc-0551b090f0117af0)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/smashpkg.rs (target/debug/deps/smashpkg-9375a78e073aacdb)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/smashtest.rs (target/debug/deps/smashtest-e843cc21338268ff)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

[0;34mRunning tests with all features enabled...[0m
[0;34mRunning tests with all features enabled...[0m
    Updating crates.io index
   Compiling memchr v2.7.4
   Compiling semver v1.0.26
   Compiling proc-macro2 v1.0.94
   Compiling unicode-ident v1.0.18
   Compiling lock_api v0.4.12
   Compiling parking_lot_core v0.9.10
   Compiling scopeguard v1.2.0
   Compiling inkwell v0.2.0
   Compiling once_cell v1.21.3
   Compiling smashlang v0.1.0 (/private/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang)
   Compiling either v1.15.0
   Compiling tempfile v3.19.1
   Compiling aho-corasick v1.1.3
   Compiling parking_lot v0.12.3
   Compiling regex-automata v0.4.9
warning: smashlang@0.1.0: src/runtime.c:113:28: warning: comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long') [-Wsign-compare]
warning: smashlang@0.1.0:   113 |     if (index < 0 || index >= len) {
warning: smashlang@0.1.0:       |                      ~~~~~ ^  ~~~
warning: smashlang@0.1.0: src/runtime.c:178:13: warning: comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long') [-Wsign-compare]
warning: smashlang@0.1.0:   178 |     if (end > len) end = len;
warning: smashlang@0.1.0:       |         ~~~ ^ ~~~
warning: smashlang@0.1.0: src/runtime.c:306:35: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   306 | char* smash_array_map(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                   ^
warning: smashlang@0.1.0: src/runtime.c:306:58: warning: unused parameter 'callback' [-Wunused-parameter]
warning: smashlang@0.1.0:   306 | char* smash_array_map(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                                          ^
warning: smashlang@0.1.0: src/runtime.c:314:38: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   314 | char* smash_array_filter(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                      ^
warning: smashlang@0.1.0: src/runtime.c:314:61: warning: unused parameter 'callback' [-Wunused-parameter]
warning: smashlang@0.1.0:   314 | char* smash_array_filter(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                                             ^
warning: smashlang@0.1.0: src/runtime.c:322:36: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   322 | char* smash_array_push(const char* array_str, const char* element) {
warning: smashlang@0.1.0:       |                                    ^
warning: smashlang@0.1.0: src/runtime.c:322:59: warning: unused parameter 'element' [-Wunused-parameter]
warning: smashlang@0.1.0:   322 | char* smash_array_push(const char* array_str, const char* element) {
warning: smashlang@0.1.0:       |                                                           ^
warning: smashlang@0.1.0: src/runtime.c:329:35: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   329 | char* smash_array_pop(const char* array_str) {
warning: smashlang@0.1.0:       |                                   ^
warning: smashlang@0.1.0: src/runtime.c:336:40: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   336 | char* smash_array_for_each(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                        ^
warning: smashlang@0.1.0: src/runtime.c:336:63: warning: unused parameter 'callback' [-Wunused-parameter]
warning: smashlang@0.1.0:   336 | char* smash_array_for_each(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                                               ^
warning: smashlang@0.1.0: src/runtime.c:343:36: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   343 | char* smash_array_find(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                    ^
warning: smashlang@0.1.0: src/runtime.c:343:59: warning: unused parameter 'callback' [-Wunused-parameter]
warning: smashlang@0.1.0:   343 | char* smash_array_find(const char* array_str, const char* callback) {
warning: smashlang@0.1.0:       |                                                           ^
warning: smashlang@0.1.0: src/runtime.c:351:36: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   351 | char* smash_array_join(const char* array_str, const char* separator) {
warning: smashlang@0.1.0:       |                                    ^
warning: smashlang@0.1.0: src/runtime.c:351:59: warning: unused parameter 'separator' [-Wunused-parameter]
warning: smashlang@0.1.0:   351 | char* smash_array_join(const char* array_str, const char* separator) {
warning: smashlang@0.1.0:       |                                                           ^
warning: smashlang@0.1.0: src/runtime.c:359:39: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   359 | char* smash_array_reverse(const char* array_str) {
warning: smashlang@0.1.0:       |                                       ^
warning: smashlang@0.1.0: src/runtime.c:366:37: warning: unused parameter 'array_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   366 | char* smash_array_slice(const char* array_str, const char* start_str, const char* end_str) {
warning: smashlang@0.1.0:       |                                     ^
warning: smashlang@0.1.0: src/runtime.c:366:60: warning: unused parameter 'start_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   366 | char* smash_array_slice(const char* array_str, const char* start_str, const char* end_str) {
warning: smashlang@0.1.0:       |                                                            ^
warning: smashlang@0.1.0: src/runtime.c:366:83: warning: unused parameter 'end_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   366 | char* smash_array_slice(const char* array_str, const char* start_str, const char* end_str) {
warning: smashlang@0.1.0:       |                                                                                   ^
warning: smashlang@0.1.0: src/runtime.c:376:49: warning: unused parameter 'object_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   376 | char* smash_object_has_own_property(const char* object_str, const char* property) {
warning: smashlang@0.1.0:       |                                                 ^
warning: smashlang@0.1.0: src/runtime.c:376:73: warning: unused parameter 'property' [-Wunused-parameter]
warning: smashlang@0.1.0:   376 | char* smash_object_has_own_property(const char* object_str, const char* property) {
warning: smashlang@0.1.0:       |                                                                         ^
warning: smashlang@0.1.0: src/runtime.c:383:37: warning: unused parameter 'object_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   383 | char* smash_object_keys(const char* object_str) {
warning: smashlang@0.1.0:       |                                     ^
warning: smashlang@0.1.0: src/runtime.c:390:39: warning: unused parameter 'object_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   390 | char* smash_object_values(const char* object_str) {
warning: smashlang@0.1.0:       |                                       ^
warning: smashlang@0.1.0: src/runtime.c:397:40: warning: unused parameter 'object_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   397 | char* smash_object_entries(const char* object_str) {
warning: smashlang@0.1.0:       |                                        ^
warning: smashlang@0.1.0: src/runtime.c:404:42: warning: unused parameter 'object_str' [-Wunused-parameter]
warning: smashlang@0.1.0:   404 | char* smash_object_to_string(const char* object_str) {
warning: smashlang@0.1.0:       |                                          ^
warning: smashlang@0.1.0: 25 warnings generated.
   Compiling quote v1.0.40
   Compiling syn v2.0.100
   Compiling regex v1.11.1
   Compiling llvm-sys v150.2.1
   Compiling inkwell_internals v0.8.0
error: No suitable version of LLVM was found system-wide or pointed
              to by LLVM_SYS_150_PREFIX.
       
              Consider using `llvmenv` to compile an appropriate copy of LLVM, and
              refer to the llvm-sys documentation for more information.
       
              llvm-sys: https://crates.io/crates/llvm-sys
              llvmenv: https://crates.io/crates/llvmenv
   --> /Users/mrp/.cargo/registry/src/index.crates.io-6f17d22bba15001f/llvm-sys-150.2.1/src/lib.rs:489:1
    |
489 | / std::compile_error!(concat!(
490 | |     "No suitable version of LLVM was found system-wide or pointed
491 | |        to by LLVM_SYS_",
492 | |     env!("CARGO_PKG_VERSION_MAJOR"),
...   |
499 | |        llvmenv: https://crates.io/crates/llvmenv"
500 | | ));
    | |__^

error: could not compile `llvm-sys` (lib) due to 1 previous error
warning: build failed, waiting for other jobs to finish...
[0;34mRunning SmashLang package tests...[0m
[0;34mTesting SmashLang packages...[0m
[0;34mFound SmashLang package tests:[0m
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/redis/tests/minimal.test.smash[0m
[0;33mWarning: smashc compiler not found, which is required for SmashLang tests[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/redis/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/redis/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/redis/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/redis/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/redis/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/pocketbase/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/pocketbase/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/pocketbase/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/pocketbase/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/pocketbase/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/pocketbase/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/postgres/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/postgres/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/postgres/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/postgres/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/postgres/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/database/postgres/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashlice/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashlice/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashlice/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashlice/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashlice/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashlice/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashier/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashier/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashier/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashier/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashier/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/smashier/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/fconvert/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/fconvert/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/fconvert/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/fconvert/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/fconvert/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/tools/fconvert/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/simple.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/simple.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/simple.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/basic.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/basic.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/microphone/tests/basic.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/input/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/input/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/input/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/input/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/input/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/input/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/camera/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/camera/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/camera/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/camera/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/camera/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/camera/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/screen/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/screen/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/screen/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/screen/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/screen/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/screen/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/devices/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/devices/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/devices/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/devices/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/devices/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/hardware/devices/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/crypto/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/crypto/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/crypto/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/crypto/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/crypto/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/crypto/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/math/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/math/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/math/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/math/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/math/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/math/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/json/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/json/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/json/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/json/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/json/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/core/json/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/websocket/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/websocket/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/websocket/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/websocket/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/websocket/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/websocket/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/smashhono/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/smashhono/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/smashhono/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/smashhono/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/smashhono/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/smashhono/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/http/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/http/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/http/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/http/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/http/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/networking/http/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/math.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/math.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/math.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/string.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/string.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/string.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/validator.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/validator.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/utils/validator.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/__package__template/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/test-package/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/test-package/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/test-package/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/ml/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/ml/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/ml/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/ml/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/ml/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/ml/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/game_engine/tests/minimal.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/game_engine/tests/minimal.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/game_engine/tests/minimal.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/game_engine/tests/index.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/game_engine/tests/index.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/smashlang_packages/community/game_engine/tests/index.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/examples/testing/basic.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/examples/testing/basic.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/examples/testing/basic.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;34mRunning SmashLang test: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/examples/testing/control_flow.test.smash[0m
SmashTest: Running tests in: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/examples/testing/control_flow.test.smash
  Found 1 test files
File: Running tests in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/examples/testing/control_flow.test.smash
Error: Failed to execute test: No such file or directory (os error 2)

SmashTest: Test Results:
  Total:   1
  Passed:  0
  Failed:  1
  Skipped: 0
  Time:    0.00s
[0;33mNo Cargo package tests found in smashlang_packages.[0m
[0;34mRunning documentation tests...[0m
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/hardware/examples/mouse_tracker.smash
Tokenizing source code
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Parsing tokens into AST
Parse error: Parse error at position 1: Expected string literal after import
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/hardware/examples/touch_visualizer.smash
Tokenizing source code
Unexpected character: $
Unexpected character: $
Unexpected character: $
Parsing tokens into AST
Parse error: Parse error at position 1: Expected string literal after import
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/hardware/examples/input_tester.smash
Tokenizing source code
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Parsing tokens into AST
Parse error: Parse error at position 1: Expected string literal after import
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/hardware/examples/keyboard_monitor.smash
Tokenizing source code
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Parsing tokens into AST
Parse error: Parse error at position 1: Expected string literal after import
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/language/examples/object-enhancements.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 0
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr: Current token: Some(String("\n=== Shorthand Property Names ===\n"))
parse_expr: Current position: 2
parse_assignment: Current token: Some(String("\n=== Shorthand Property Names ===\n"))
parse_primary: Current token: Some(String("\n=== Shorthand Property Names ===\n"))
parse_expr result: true
parse_expr result: true
parse_expr: Current token: Some(String("Alice"))
parse_expr: Current position: 8
parse_assignment: Current token: Some(String("Alice"))
parse_primary: Current token: Some(String("Alice"))
parse_expr result: true
parse_expr: Current token: Some(String("Johnson"))
parse_expr: Current position: 13
parse_assignment: Current token: Some(String("Johnson"))
parse_primary: Current token: Some(String("Johnson"))
parse_expr result: true
parse_expr: Current token: Some(Number(32))
parse_expr: Current position: 18
parse_assignment: Current token: Some(Number(32))
parse_primary: Current token: Some(Number(32))
parse_expr result: true
parse_expr: Current token: Some(LBrace)
parse_expr: Current position: 23
parse_assignment: Current token: Some(LBrace)
parse_primary: Current token: Some(LBrace)
parse_expr: Current token: Some(Identifier("firstName"))
parse_expr: Current position: 26
parse_assignment: Current token: Some(Identifier("firstName"))
parse_primary: Current token: Some(Identifier("firstName"))
parse_expr result: true
parse_expr: Current token: Some(Identifier("lastName"))
parse_expr: Current position: 30
parse_assignment: Current token: Some(Identifier("lastName"))
parse_primary: Current token: Some(Identifier("lastName"))
parse_expr result: true
parse_expr: Current token: Some(Identifier("age"))
parse_expr: Current position: 34
parse_assignment: Current token: Some(Identifier("age"))
parse_primary: Current token: Some(Identifier("age"))
parse_expr result: true
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 37
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr: Current token: Some(String("Traditional syntax:"))
parse_expr: Current position: 39
parse_assignment: Current token: Some(String("Traditional syntax:"))
parse_primary: Current token: Some(String("Traditional syntax:"))
parse_expr result: true
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 42
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr: Current token: Some(Identifier("user1"))
parse_expr: Current position: 44
parse_assignment: Current token: Some(Identifier("user1"))
parse_primary: Current token: Some(Identifier("user1"))
parse_expr result: true
parse_expr result: true
parse_expr: Current token: Some(LBrace)
parse_expr: Current position: 50
parse_assignment: Current token: Some(LBrace)
parse_primary: Current token: Some(LBrace)
parse_expr result: false
Parse error: Parse error at position 52: Expected colon after property name in object literal
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/language/examples/destructuring.smash
Tokenizing source code
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Unexpected character: $
Parsing tokens into AST
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 0
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr: Current token: Some(String("\n=== Array Destructuring ===\n"))
parse_expr: Current position: 2
parse_assignment: Current token: Some(String("\n=== Array Destructuring ===\n"))
parse_primary: Current token: Some(String("\n=== Array Destructuring ===\n"))
parse_expr result: true
parse_expr result: true
Parse error: Parse error at position 6: Expected identifier after let
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(5))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(5))
parse_primary: Current token: Some(Number(5))
parse_expr result: true
parse_expr: Current token: Some(String("Hello"))
parse_expr: Current position: 8
parse_assignment: Current token: Some(String("Hello"))
parse_primary: Current token: Some(String("Hello"))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 10
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features_compiled.c
AST: [LetDecl { name: "count", value: Number(5) }, LetDecl { name: "message", value: String("Hello") }, Identifier("print")]
Saved C code to /tmp/smash_debug_90680.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* count = (char*)"5";
    char* message = "Hello";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features_compiled.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features_compiled.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features_compiled.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features_compiled.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(5))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(5))
parse_primary: Current token: Some(Number(5))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 5
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals_compiled.c
AST: [LetDecl { name: "x", value: Number(5) }, Identifier("print")]
Saved C code to /tmp/smash_debug_90754.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* x = (char*)"5";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals_compiled.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals_compiled.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals_compiled.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals_compiled.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 0
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world_compiled.c
AST: [Identifier("print")]
Saved C code to /tmp/smash_debug_90826.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world_compiled.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world_compiled.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world_compiled.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world_compiled.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 0
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions_compiled.c
AST: [Identifier("print")]
Saved C code to /tmp/smash_debug_90902.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions_compiled.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions_compiled.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions_compiled.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions_compiled.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(10))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(10))
parse_primary: Current token: Some(Number(10))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 5
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables_compiled.c
AST: [LetDecl { name: "x", value: Number(10) }, Identifier("print")]
Saved C code to /tmp/smash_debug_90974.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* x = (char*)"10";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables_compiled.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables_compiled.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables_compiled.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables_compiled.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(0))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(0))
parse_primary: Current token: Some(Number(0))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 5
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops_compiled.c
AST: [LetDecl { name: "i", value: Number(0) }, Identifier("print")]
Saved C code to /tmp/smash_debug_91046.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* i = (char*)"0";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops_compiled.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops_compiled.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops_compiled.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
/var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops_compiled.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
[0;33mWarning: Some tests failed. Continuing with installation...[0m
[0;33m  - Main crate tests failed[0m
[0;33m  - SmashLang package tests failed[0m
[0;33m  - Documentation tests failed[0m
[0;34mRunning example tests...[0m
===== SmashLang Examples Test Script =====
Testing all examples in /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started

Testing example: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world.smash
-----------------------------------
Source code:
// SmashLang Example 1: Hello World
// This is the simplest SmashLang program that prints a message

// In SmashLang, statements end with semicolons
print;

// The current implementation will print a default message
// Future versions will support: print "Hello, World!";

Compiling...
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 0
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at 01_hello_world.c
AST: [Identifier("print")]
Saved C code to /tmp/smash_debug_91125.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
01_hello_world.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
01_hello_world.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
01_hello_world.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
01_hello_world.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Compilation failed!
Test failed for /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/01_hello_world.smash
Testing example: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables.smash
-----------------------------------
Source code:
// SmashLang Example 2: Variables
// This example demonstrates how to declare and use variables

// Declare a variable using 'let' with an initializer
let x = 10;

// Declare a constant using 'const'
// Note: In the current implementation, this is parsed but not fully implemented
// const PI = 3.14159;

// Variables can be used in expressions
// Future versions will support: let y = x + 5;

// Print the result
print;

Compiling...
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(10))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(10))
parse_primary: Current token: Some(Number(10))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 5
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at 02_variables.c
AST: [LetDecl { name: "x", value: Number(10) }, Identifier("print")]
Saved C code to /tmp/smash_debug_91193.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* x = (char*)"10";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
02_variables.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
02_variables.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
02_variables.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
02_variables.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Compilation failed!
Test failed for /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/02_variables.smash
Testing example: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals.smash
-----------------------------------
Source code:
// SmashLang Example 3: Conditionals
// This example demonstrates if/else statements

// Declare a variable with an initializer
let x = 5;

// If statement
// Note: In the current implementation, this is parsed but not fully implemented in code generation
// if (x > 0) {
//   print;
// } else {
//   print;
// }

// For now, we'll just use a simple statement
print;

// Future versions will support full conditional logic with comparison operators

Compiling...
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(5))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(5))
parse_primary: Current token: Some(Number(5))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 5
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at 03_conditionals.c
AST: [LetDecl { name: "x", value: Number(5) }, Identifier("print")]
Saved C code to /tmp/smash_debug_91261.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* x = (char*)"5";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
03_conditionals.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
03_conditionals.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
03_conditionals.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
03_conditionals.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Compilation failed!
Test failed for /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/03_conditionals.smash
Testing example: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops.smash
-----------------------------------
Source code:
// SmashLang Example 4: Loops
// This example demonstrates different types of loops

// Declare a counter variable with an initializer
let i = 0;

// While loop
// Note: In the current implementation, this is parsed but not fully implemented in code generation
// while (i < 10) {
//   print;
//   i = i + 1;
// }

// For loop
// Note: In the current implementation, this is parsed but not fully implemented in code generation
// for (let j = 0; j < 5; j = j + 1) {
//   print;
// }

// Do-while loop
// Note: In the current implementation, this is parsed but not fully implemented in code generation
// do {
//   print;
//   i = i + 1;
// } while (i < 5);

// For now, we'll just use a simple statement
print;

// Future versions will support all loop types with proper code generation

Compiling...
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(0))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(0))
parse_primary: Current token: Some(Number(0))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 5
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at 04_loops.c
AST: [LetDecl { name: "i", value: Number(0) }, Identifier("print")]
Saved C code to /tmp/smash_debug_91329.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* i = (char*)"0";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
04_loops.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
04_loops.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
04_loops.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
04_loops.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Compilation failed!
Test failed for /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/04_loops.smash
Testing example: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions.smash
-----------------------------------
Source code:
// SmashLang Example 5: Functions
// This example demonstrates how to define and call functions

// Function declaration
// Note: In the current implementation, this is parsed but not fully implemented in code generation
// fn add(a, b) {
//   return a + b;
// }

// Function call
// Note: In the current implementation, this is parsed but not fully implemented in code generation
// let result = add(5, 3);

// Print the result
// Future versions will support: print result;
print;

// Future versions will support full function declarations and calls

Compiling...
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 0
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at 05_functions.c
AST: [Identifier("print")]
Saved C code to /tmp/smash_debug_91397.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
05_functions.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
05_functions.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
05_functions.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
05_functions.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Compilation failed!
Test failed for /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/05_functions.smash
Testing example: /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features.smash
-----------------------------------
Source code:
// SmashLang Example 6: Combined Features
// This example demonstrates multiple language features working together

// Variable declarations with initializers
let count = 5;
let message = "Hello";

// Note: In the current implementation, string operations are parsed but not fully implemented
// The following code shows the intended syntax for future versions:
//
// // Function declaration
// fn countdown(start) {
//   let current = start;
//   while (current > 0) {
//     print current;
//     current = current - 1;
//   }
//   print "Blast off!";
// }
//
// // Conditional logic
// if (count > 0) {
//   // Function call
//   countdown(count);
// } else {
//   print "Count is zero or negative";
// }

// For the current implementation, we'll use a simple statement
print;

// This example shows how variables, functions, conditionals, and loops
// can be combined to create more complex programs in SmashLang

Compiling...
Reading /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features.smash
Tokenizing source code
Parsing tokens into AST
parse_expr: Current token: Some(Number(5))
parse_expr: Current position: 3
parse_assignment: Current token: Some(Number(5))
parse_primary: Current token: Some(Number(5))
parse_expr result: true
parse_expr: Current token: Some(String("Hello"))
parse_expr: Current position: 8
parse_assignment: Current token: Some(String("Hello"))
parse_primary: Current token: Some(String("Hello"))
parse_expr result: true
parse_expr: Current token: Some(Identifier("print"))
parse_expr: Current position: 10
parse_assignment: Current token: Some(Identifier("print"))
parse_primary: Current token: Some(Identifier("print"))
parse_expr result: true
Generating intermediate code
Info: C file will be saved at 06_combined_features.c
AST: [LetDecl { name: "count", value: Number(5) }, LetDecl { name: "message", value: String("Hello") }, Identifier("print")]
Saved C code to /tmp/smash_debug_91465.c
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <dlfcn.h>

// Helper function for string concatenation
char* smash_string_concat(const char* a, const char* b) {
    size_t len_a = strlen(a);
    size_t len_b = strlen(b);
    char* result = (char*)malloc(len_a + len_b + 1);
    if (result) {
        strcpy(result, a);
        strcat(result, b);
    }
    return result;
}

// Helper function for getting string length
char* smash_get_length(const char* str) {
    size_t len = strlen(str);
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%zu", len);
    char* result = (char*)malloc(strlen(buffer) + 1);
    if (result) {
        strcpy(result, buffer);
    }
    return result;
}

// Helper function for converting string to uppercase
char* smash_string_to_upper(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = toupper(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for converting string to lowercase
char* smash_string_to_lower(const char* str) {
    size_t len = strlen(str);
    char* result = (char*)malloc(len + 1);
    if (result) {
        for (size_t i = 0; i < len; i++) {
            result[i] = tolower(str[i]);
        }
        result[len] = ' ';
    }
    return result;
}

// Helper function for trimming whitespace from a string
char* smash_string_trim(const char* str) {
    size_t len = strlen(str);
    size_t start = 0, end = len;
    
    // Find start index (first non-whitespace)
    while (start < len && isspace(str[start])) {
        start++;
    }
    
    // Find end index (last non-whitespace)
    while (end > start && isspace(str[end - 1])) {
        end--;
    }
    
    // Create result string
    size_t result_len = end - start;
    char* result = (char*)malloc(result_len + 1);
    if (result) {
        strncpy(result, str + start, result_len);
        result[result_len] = ' ';
    }
    return result;
}

// Note: These are simplified implementations for demonstration purposes
// In a real implementation, we would need proper array handling
// Helper function for array map operation
char* smash_array_map(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array. For now, we'll just return a placeholder.
    return strdup("[Mapped Array]");
}

// Helper function for array filter operation
char* smash_array_filter(const char* array, const char* callback) {
    // In a real implementation, this would parse the array, apply the callback to each element,
    // and return a new array with elements that pass the test. For now, we'll just return a placeholder.
    return strdup("[Filtered Array]");
}

// Helper function for array push operation
char* smash_array_push(const char* array, const char* item) {
    // In a real implementation, this would parse the array, add the item, and return the new array.
    // For now, we'll just return a placeholder.
    return strdup("[Array with pushed item]");
}

// Helper function for array pop operation
char* smash_array_pop(const char* array) {
    // In a real implementation, this would parse the array, remove the last item, and return that item.
    // For now, we'll just return a placeholder.
    return strdup("[Popped item]");
}

// Embedded regex implementation for JavaScript-like support
#include <pcre.h>  // Use PCRE for JavaScript-compatible regex

// Structure to hold regex pattern and compiled regex
typedef struct {
    char* pattern;     // Original pattern string
    char* flags;       // Flags (i, g, m, etc.)
    pcre* re;          // Compiled regex
    pcre_extra* extra; // Optimized regex data
} SmashRegex;

// Create a new regex pattern
SmashRegex* smash_regex_create(const char* pattern, const char* flags) {
    if (!pattern) return NULL;
    
    SmashRegex* regex = (SmashRegex*)malloc(sizeof(SmashRegex));
    if (!regex) return NULL;
    // Initialize to NULL so we can safely free in case of error
    regex->pattern = NULL;
    regex->flags = NULL;
    regex->re = NULL;
    regex->extra = NULL;
    // Copy pattern and flags
    regex->pattern = strdup(pattern);
    regex->flags = flags ? strdup(flags) : strdup("");
    if (!regex->pattern || !regex->flags) {
        smash_regex_free(regex);
        return NULL;
    }
    // Build PCRE options based on flags
    int options = 0;
    if (strchr(regex->flags, 'i')) options |= PCRE_CASELESS;
    if (strchr(regex->flags, 'm')) options |= PCRE_MULTILINE;
    if (strchr(regex->flags, 's')) options |= PCRE_DOTALL;
    // Compile the regex
    const char* error;
    int erroffset;
    regex->re = pcre_compile(pattern, options, &error, &erroffset, NULL);
    if (!regex->re) {
        fprintf(stderr, "Regex compilation failed at offset %d: %s\n", erroffset, error);
        smash_regex_free(regex);
        return NULL;
    }
    // Study the pattern for optimization
    regex->extra = pcre_study(regex->re, 0, &error);
    if (error) {
        fprintf(stderr, "Regex study failed: %s\n", error);
        // Continue without the optimization
    }
    return regex;
}

// Free a regex pattern
void smash_regex_free(SmashRegex* regex) {
    if (!regex) return;
    
    if (regex->pattern) free(regex->pattern);
    if (regex->flags) free(regex->flags);
    if (regex->extra) pcre_free(regex->extra);
    if (regex->re) pcre_free(regex->re);
    free(regex);
}

// Test if a string matches a regex pattern
int smash_regex_test(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return 0;
    
    int ovector[30];  // Output vector for match offsets
    int rc = pcre_exec(regex->re, regex->extra, str, strlen(str), 0, 0, ovector, 30);
    
    // Return 1 for match, 0 for no match
    return (rc >= 0) ? 1 : 0;
}

// Find matches in a string (returns JSON array of matches)
char* smash_regex_match(SmashRegex* regex, const char* str) {
    if (!regex || !str || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Buffer to build JSON array of matches
    char* result = strdup("[]");
    if (!result) return NULL;
    
    // Find all matches
    int match_count = 0;
    while (start_offset < str_len) {
        int rc = pcre_exec(regex->re, regex->extra, str, str_len, start_offset, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Extract the matched substring
        int match_len = ovector[1] - ovector[0];
        char* match = (char*)malloc(match_len + 1);
        if (!match) {
            free(result);
            return NULL;
        }
        
        strncpy(match, str + ovector[0], match_len);
        match[match_len] = ' ';
        
        // Add to JSON array
        if (match_count == 0) {
            // First match, replace empty array
            free(result);
            result = (char*)malloc(match_len + 5);  // Array format
            if (!result) {
                free(match);
                return NULL;
            }
            sprintf(result, "[\"%s\"]", match);
        } else {
            // Append to existing array
            int old_len = strlen(result);
            char* new_result = (char*)malloc(old_len + match_len + 5);  // For appending
            if (!new_result) {
                free(match);
                free(result);
                return NULL;
            }
            // Remove trailing ]
            result[old_len - 1] = ' ';
            sprintf(new_result, "%s,\"%s\"]", result, match);
            free(result);
            result = new_result;
        }
        
        free(match);
        match_count++;
        
        // If not global, stop after first match
        if (!global) break;
        
        // Move to position after the match
        start_offset = ovector[1];
        // Avoid infinite loop on zero-length matches
        if (ovector[0] == ovector[1]) start_offset++;
    }
    
    return result;
}

// Replace matches in a string
char* smash_regex_replace(SmashRegex* regex, const char* str, const char* replacement) {
    if (!regex || !str || !replacement || !regex->re) return NULL;
    
    int ovector[30];  // Output vector for match offsets
    int str_len = strlen(str);
    int repl_len = strlen(replacement);
    int start_offset = 0;
    int global = strchr(regex->flags, 'g') != NULL;
    
    // Initial buffer size estimate
    int buffer_size = str_len * 2;  // Start with twice the input size
    if (buffer_size < 1024) buffer_size = 1024;  // Minimum buffer size
    char* result = (char*)malloc(buffer_size);
    if (!result) return NULL;
    
    // Copy the input string to start with
    strcpy(result, str);
    
    // Find and replace all matches
    int match_count = 0;
    char* current = result;
    
    while (1) {
        int rc = pcre_exec(regex->re, regex->extra, current, strlen(current), 0, 0, ovector, 30);
        if (rc < 0) break;  // No more matches
        
        // Calculate new string length
        int match_len = ovector[1] - ovector[0];
        int new_len = strlen(current) - match_len + repl_len;
        
        // Create temporary buffer for the replacement
        char* temp = (char*)malloc(new_len + 1);
        if (!temp) {
            free(result);
            return NULL;
        }
        
        // Copy parts before match
        strncpy(temp, current, ovector[0]);
        temp[ovector[0]] = ' ';
        
        // Copy replacement
        strcat(temp, replacement);
        
        // Copy parts after match
        strcat(temp, current + ovector[1]);
        
        // Replace current with the new string
        if (current == result) {
            free(result);
            result = temp;
            current = result;
        } else {
            free(current);
            current = temp;
        }
        
        match_count++;
        
        // If not global, stop after first replacement
        if (!global) break;
    }
    
    // If no replacements were made, ensure we return a copy of the original
    if (match_count == 0) {
        free(result);
        return strdup(str);
    }
    
    return result;
}

// Free a string returned by regex functions
void smash_free_string(char* str) {
    free(str);
}

// No need to load external library, using embedded implementation
int load_regex_library() {
    return 1;  // Always succeeds with embedded implementation
}
// Helper function for string.match with regex
char* smash_string_match(const char* str, const char* pattern) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Match the regex against the string
    char* result = smash_regex_match(regex, str);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

// Helper function for string.replace with regex
char* smash_string_replace(const char* str, const char* pattern, const char* replacement) {
    // If pattern is a regex object (starts with 'SmashRegex:'), use it directly
    // Otherwise, create a new regex object
    SmashRegex* regex;
    int should_free = 0;
    
    if (strncmp(pattern, "SmashRegex:", 11) == 0) {
        // Extract the regex pointer from the string
        sscanf(pattern + 11, "%p", &regex);
    } else {
        // Create a new regex object from the pattern string
        regex = smash_regex_create(pattern, "");
        should_free = 1;
    }
    
    // Replace matches in the string
    char* result = smash_regex_replace(regex, str, replacement);
    
    // Free the regex if we created it
    if (should_free) {
        smash_regex_free(regex);
    }
    
    return result;
}

int main(int argc, char** argv) {
    // Initialize the regex library
    if (!load_regex_library()) {
        fprintf(stderr, "Failed to load regex library. Regex operations will not work.\n");
    }

    char* count = (char*)"5";
    char* message = "Hello";
    // Unimplemented AST node type
    return 0;
};

Compiling executable
Linking executable
06_combined_features.c:40:24: warning: null character(s) preserved in char literal [-Wnull-character]
   40 |         result[len] = '<U+0000>';
      |                        ^
06_combined_features.c:53:24: warning: null character(s) preserved in char literal [-Wnull-character]
   53 |         result[len] = '<U+0000>';
      |                        ^
06_combined_features.c:78:31: warning: null character(s) preserved in char literal [-Wnull-character]
   78 |         result[result_len] = '<U+0000>';
      |                               ^
06_combined_features.c:114:10: fatal error: 'pcre.h' file not found
  114 | #include <pcre.h>  // Use PCRE for JavaScript-compatible regex
      |          ^~~~~~~~
3 warnings and 1 error generated.
Error: Failed to compile and link direct test code
Compilation failed!
Test failed for /var/folders/8q/8780tcfn1rb821f6bg6mvfyc0000gn/T/tmp.qNui0TYBX8/smashlang/docs/getting-started/06_combined_features.smash
Some examples failed to compile or run.
[0;34mTesting SmashLang packages...[0m
[0;34mTesting individual packages...[0m
[0;32mAll package tests passed successfully![0m
